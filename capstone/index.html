
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rock+Salt&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/TextPlugin.min.js"></script>
<title>The Story</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
background-color: #FFFEEB;
height: 100vh;
overflow: hidden;
font-family: Arial, sans-serif;
cursor: default;
}
.rotation-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(0px);
width: 400px;
height: 400px;
}
.circle {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 300px;
height: 300px;
border-radius: 50%;
background-image: url('images/circle-scale.svg'); /* Replace the gradient with your image */
background-size: cover;
background-position: center;
box-shadow: 0 0 50px rgba(0, 0, 0, 0.3);
z-index: 1;
}
.tree-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(210px);
width: 400px;
height: 400px;
z-index: 2;
}
.tree-img {
position: absolute;
width: 30px;
height: 40px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.oil-rig-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 3;
}
.oil-rig-img {
position: absolute;
width: 40px;
height: 50px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.antenna-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 4;
}
.antenna-img {
position: absolute;
width: 35px;
height: 45px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.city-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 1;
}
.city-img {
position: absolute;
width: 35px;
height: 45px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.nuclear-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 6;
}
.nuclear-img {
position: absolute;
width: 35px;
height: 45px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.smokestacks-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 7;
}
.smokestacks-img {
position: absolute;
width: 35px;
height: 45px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.space-junk-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(205px);
width: 400px;
height: 400px;
z-index: 8;
}
.space-junk-img {
position: absolute;
width: 35px;
height: 45px;
top: 0;
left: 50%;
transform: translateX(-50%);
opacity: 0;
}
.controls-info {
display: none;
position: fixed;
top: 20px;
left: 20px;
color: white;
font-size: 14px;
background: rgba(0, 0, 0, 0.7);
padding: 15px;
border-radius: 10px;
z-index: 1000;
backdrop-filter: blur(10px);
}
.time-indicator {
display: none;
position: fixed;
top: 20px;
right: 20px;
color: white;
font-size: 18px;
font-weight: bold;
background: rgba(0, 0, 0, 0.7);
padding: 15px;
border-radius: 10px;
z-index: 1000;
backdrop-filter: blur(10px);
}
.mouse-zones {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 999;
}

.mouse-zones .zone {
pointer-events: auto;
}
.zone {
position: absolute;
opacity: 0.05;
transition: opacity 0.8s ease;
}
.zone.left {
left: 0;
top: 0;
width: 30%;
height: 100%;
background: linear-gradient(to right, rgba(255, 100, 100, 0.3), transparent);

/* testing */
background: transparent !important;
/* testing */
}
.zone.right {
right: 0;
top: 0;
width: 30%;
height: 100%;
background: linear-gradient(to left, rgba(100, 255, 100, 0.3), transparent);

/* testing */
background: transparent !important;
/* testing */
}
.zone.center {
left: 30%;
top: 0;
width: 40%;
height: 100%;
background: rgba(100, 100, 255, 0.2);

/* testing */
background: transparent !important;
/* testing */
}
.zone.active {
opacity: 0.2;
}

.tutorial-right {
position: absolute;
height: 100px;
width: 200px;
right: 50px;
top: 50%;
opacity: 1;
transition: opacity 0.6s ease;

}


.tutorial-left {

position: absolute;
height: 100px;
width: 200px;
left: 200px;
top: 50%;
opacity: 1;
transition: opacity 0.6s ease;


}

.tutorial-center {
position: absolute;
height: 100px;
width: 200px;
top: 75%;
margin-left: 50vw;
opacity: 1;
transition: opacity 0.6s ease;

}

.tutorial-center p, .tutorial-right p, .tutorial-left p {
color: rgb(1, 15, 10);
font-family: "Rock Salt", cursive;
font-size: 24px;
}

.overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(30, 30, 30, 0.9);
color: white;
display: flex;
display: none;
align-items: center;
justify-content: center;
z-index: 2000;
}

.overlay-content {
text-align: center;
max-width: 400px;
padding: 20px;
background: #222;
border-radius: 10px;
position: relative;
}

.close-btn {
position: absolute;
top: 10px;
right: 15px;
background: none;
border: none;
font-size: 24px;
color: white;
cursor: pointer;
}

.overlay h2 {
margin-bottom: 15px;
font-size: 24px;
}

.overlay ul {
list-style: none;
padding: 0;
text-align: left;
}

.overlay li {
margin: 10px 0;
font-size: 16px;
}

.year-indicator {
display: none;
position: absolute;
top: 92%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(0px);
width: 300px;
height: 10px;


}

.p1 {

float: left;
color: black;
font-family: Arial, Helvetica, sans-serif;
font-size: 12px;


}

.p2 {

float: right;
color: black;
font-family: Arial, Helvetica, sans-serif;
font-size: 12px;


}

.timeline-indicator {
display: none;
position: absolute;
top: 95%;
left: 50%;
transform: translate(-50%, -50%) translateX(0px) translateY(0px);
width: 300px;
height: 10px;
background-color: black;
overflow: hidden;

}

.timeline-indicator img {

width: 15px;
height: 15px;
position: relative;
top: -20px;
left: 0;

}

.red-zone {

position: relative;
background-color: rgb(230, 61, 14);
height: 10px;
width: 100px;
left: 250px;
top: -10px;
}

.yellow-zone {

position: relative;
background-color: rgb(245, 176, 46);
height: 10px;
width: 60px;
left: 200px;
}

.ln1 {

position: relative;
width: 2px;
height: 12px;
background-color: white;
top: -39px;
left: 25%

}

.ln2 {

position: relative;
width: 2px;
height: 12px;
background-color: white;
top: -50px;
left: 50%

}

.ln3 {

position: relative;
width: 2px;
height: 12px;
background-color: white;
top: -60px;
left: 75%

}

.nav-1{

  display: flex;
  position: fixed;
  width: 100vw;
  height: 100vh;
  background-color: #FFFEEB;
  justify-content: center;
  align-items: center;
  z-index: 2000;

}

.nav-2 {

display: none;
position: fixed;
width: 100vw;
height: 100vh;
background-color: #FFFEEB;
justify-content: center;
align-items: center;
z-index: 2000;

}

.nav-3 {

display: none;
position: fixed;
width: 100vw;
height: 100vh;
background-color: #FFFEEB;
justify-content: center;
align-items: center;
z-index: 2000;

}

.nav-4 {

display: none;
position: fixed;
width: 100vw;
height: 100vh;
background-color: #FFFEEB;
justify-content: center;
align-items: center;
z-index: 2000;

}

.nav-5 {

display: none;
position: fixed;
width: 100vw;
height: 100vh;
background-color: #FFFEEB;
justify-content: center;
align-items: center;
z-index: 2000;

}





.nav-window, .nav-window-2, .nav-window-3, .nav-window-4, .nav-window-5{

  width: 350px;
  padding: 30px;
  background-color: white;
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  text-align: left;



}


.nav-window .button img,.nav-window-2 .button img, .nav-window-3 .button img, .nav-window-4 .button img, .nav-window-5 .button img {
  width: 20px;
  height: auto;
}

.nav-window .button, .nav-window-2 .button, .nav-window-3 .button, .nav-window-4 .button, .nav-window-5 .button{
  display: flex;
  align-items: center;
  justify-content: right;
  gap: 10px;
  cursor: pointer;
  font-family: Arial, sans-serif;
  font-size: 16px;
  font-weight: bold;
  color: #222;
  flex-direction: row;  /* Ensure it's horizontally aligned */
}





@keyframes fadeOut {
from {
opacity: 1;
}
to {
opacity: 0;
}
}

.fade-out {
animation: fadeOut 0.6s ease forwards;
}

@media screen and (min-width: 800px) {

.tutorial-right {
right: 200px;
}

.nav-window {
    width: 700px;
  }

  .nav-window-2 {
    width: 700px;
  }

  .nav-window-3 {
    width: 700px;
  }

  .nav-window-4 {
    width: 700px;
  }

  .nav-window-5 {
    width: 700px;
  }

}
</style>
</head>
<body>
<div class="mouse-zones">
<div class="zone left" id="leftZone"></div>
<div class="zone center" id="centerZone"></div>
<div class="zone right" id="rightZone"></div>
<!-- test tools -->
</div>
<div class="controls-info">

<div><strong>World Evolution Control:</strong></div>
<div>Left: Reverse Time (Trees Disappear)</div>
<div>Right: Forward Time (Trees Appear)</div>
<div>Center: Neutral (Slow Spin)</div>
</div>

<!-- tutorial -->
<div class="tutorial-right">
<p class="text-2">hover right to go forwards.</p>

</div>
<div class="tutorial-left">
<p class="text-2">hover left to go backwards.</p>

</div>
<div class="tutorial-center">
<p class="text-2">hover over the center to slow down time.</p>
</div>

<div id="userTestOverlay" class="overlay">
<div class="overlay-content">
<button id="closeOverlay" class="close-btn">✕</button>
<h2>User Test</h2>
<ul>
<li>Hover right to go forward in time</li>
<li>Hover left to go back in time</li>
<li>Hover center to slow down time</li>
</ul>
</div>
</div>


<div class="time-indicator" id="timeIndicator"></div>

<div class="timeline-indicator">
<div class="yellow-zone"></div>
<div class="red-zone"></div>
<img src="images/indicator-1.png"> 

<div class="ln1"></div>
<div class="ln2"></div>
<div class="ln3"></div>
</div>

<div class="year-indicator"> 
<p class="p1">CO2 timeline</p>
<p class="p2">2035AD</p>



</div>





<!-- main -->
<div class="rotation-container" id="rotationContainer">
<div class="circle"></div>
<div class="tree-container" id="treeContainer"></div>
<div class="oil-rig-container" id="oilRigContainer"></div>
<div class="antenna-container" id="antennaContainer"></div>
<div class="city-container" id="cityContainer"></div>
<div class="nuclear-container" id="nuclearContainer"></div>
<div class="smokestacks-container" id="smokestacksContainer"></div>
<div class="space-junk-container" id="spaceJunkContainer"></div>
</div>

<div class="nav-1">
 
<div class="nav-window">
  <h1 class="text">Our world as invisioned:
    beginning one thousand years ago.
  </h1>
  <div class="button">
    <p>Start Experience</p><img src="images/arrow-1.svg" alt="arrow">
  </div>
</div>
</div>

<div class="nav-2">
 
  <div class="nav-window-2">
    <h1 class="text-2">Prior to the Industrial Age, CO2 emissions were at their lowest in Earth's history.
    </h1>
    <div class="button">
      <p>Continue</p><img src="images/arrow-1.svg" alt="arrow">
    </div>
  </div>
</div>
</div>

<div class="nav-3">
 
  <div class="nav-window-3">
    <h1 class="text-3">By current times, global warming reached a point of no return.
    </h1>
    <div class="button">
      <p>Continue</p><img src="images/arrow-1.svg" alt="arrow">
    </div>
  </div>
</div>
</div>

<div class="nav-4">
 
  <div class="nav-window-4">
    <h1 class="text-4">A thousand years in the future, global warming and environmental pollution made Earth unsuitable for almost all life.
    </h1>
    <div class="button">
      <p>Continue</p><img src="images/arrow-1.svg" alt="arrow">
    </div>
  </div>
</div>
</div>

<div class="nav-5">
 
  <div class="nav-window-5">
    <h1 class="text-5">If it could be done again, we could learn to live harmoniously with nature instead of causing irreversable damage.
    </h1>
    <div class="button">
      <p>A better future</p><img src="images/arrow-1.svg" alt="arrow">
    </div>
  </div>
</div>
</div>


<script>
  (function() {
    // Configuration object - easy to modify and understand
    const ELEMENTS = {
      trees: {
        total: 34,
        src: "images/trees-04.png",
        className: "tree-img",
        containerID: "treeContainer",
        yPos: -200,
        rotation: 90,
        transformOrigin: "50% 190px"
      },
      cities: {
        total: 6,
        src: "images/city-1.png", 
        className: "city-img",
        containerID: "cityContainer",
        yPos: -202,
        rotation: 10,
        transformOrigin: "50% 195px"
      },
      oilRigs: {
        total: 3,
        src: "images/oil-rig-01.png",
        className: "oil-rig-img", 
        containerID: "oilRigContainer",
        yPos: -205,
        rotation: 90,
        transformOrigin: "50% 200px"
      },
      antennas: {
        total: 5,
        src: "images/antenna-01.png",
        className: "antenna-img",
        containerID: "antennaContainer", 
        yPos: -202,
        rotation: 55,
        transformOrigin: "50% 195px"
      },
      nuclear: {
        total: 3,
        src: "images/nuclear-1.png",
        className: "nuclear-img",
        containerID: "nuclearContainer",
        yPos: -202,
        rotation: 40,
        transformOrigin: "50% 195px"
      },
      smokestacks: {
        total: 5,
        src: "images/smokestacks-1.png",
        className: "smokestacks-img",
        containerID: "smokestacksContainer",
        yPos: -202,
        rotation: 25,
        transformOrigin: "50% 195px"
      },
      spaceJunk: {
        total: 3,
        src: "images/space-junk-1.png",
        className: "space-junk-img",
        containerID: "spaceJunkContainer",
        yPos: -202,
        rotation: 57,
        transformOrigin: "50% 195px"
      }
    };
  
    // Global state object - keeps everything organized
    const gameState = {
      isReinterpretationMode: false,
      splashesDisabled: false,
      navShown: { nav2: false, nav3: false, nav4: false, nav5: false },
      elements: {}, // Will hold all element arrays
      counts: {}, // Will hold all current counts
      containers: {}, // Will hold all container references
      intervals: { rotation: null, growth: null, shrink: null }
    };
  
    // Function to reset cursor to center
    function resetCursorToCenter() {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      
      const centerElement = document.createElement('div');
      centerElement.style.position = 'fixed';
      centerElement.style.left = centerX + 'px';
      centerElement.style.top = centerY + 'px';
      centerElement.style.width = '1px';
      centerElement.style.height = '1px';
      centerElement.style.pointerEvents = 'none';
      centerElement.style.zIndex = '9999';
      document.body.appendChild(centerElement);
      
      const event = new MouseEvent('mousemove', {
        clientX: centerX,
        clientY: centerY,
        bubbles: true
      });
      document.dispatchEvent(event);
      
      setTimeout(() => {
        document.body.removeChild(centerElement);
      }, 100);
    }
  
    // Unified function to create any element
    function createElement(type) {
      const config = ELEMENTS[type];
      const img = document.createElement("img");
      img.src = config.src;
      img.className = config.className;
      return img;
    }
  
    // Calculate viewport edge position
    function getViewportEdgePosition(angle) {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const maxDistance = Math.max(window.innerWidth, window.innerHeight);
      const radians = (angle - 90) * (Math.PI / 180);
      const edgeX = centerX + Math.cos(radians) * maxDistance;
      const edgeY = centerY + Math.sin(radians) * maxDistance;
      return { x: edgeX, y: edgeY };
    }
  
    // Unified function to initialize elements of any type
    function initializeElements(type) {
      const config = ELEMENTS[type];
      if (!config) {
        console.error(`Element config for type '${type}' not found`);
        return;
      }
      
      const container = gameState.containers[type];
      if (!container) {
        console.error(`Container for type '${type}' not found`);
        return;
      }
      
      const total = gameState.isReinterpretationMode && type === 'trees' ? 34 : 
                    gameState.isReinterpretationMode && type === 'cities' ? 12 : config.total;
      
      gameState.elements[type] = [];
      gameState.counts[type] = 0;
      
      for (let i = 0; i < total; i++) {
        const element = createElement(type);
        container.appendChild(element);
        const rotationAngle = (360 / total) * i;
        
        gsap.set(element, {
          rotation: rotationAngle + config.rotation,
          transformOrigin: config.transformOrigin,
          opacity: 0,
          scale: 0,
          y: config.yPos
        });
        
        gameState.elements[type].push({
          element: element,
          index: i,
          angle: rotationAngle,
          grown: false
        });
      }
    }
  
    // Unified function to grow any element type
    function growRandomElement(type) {
      if (!gameState.elements[type] || !Array.isArray(gameState.elements[type])) {
        console.error(`Elements array for type '${type}' not found or invalid`);
        return;
      }
      
      const ungrownElements = gameState.elements[type].filter(item => item && !item.grown);
      if (ungrownElements.length === 0) return;
      
      const randomElement = ungrownElements[Math.floor(Math.random() * ungrownElements.length)];
      if (!randomElement || !randomElement.element) {
        console.error(`Invalid element selected for type '${type}'`);
        return;
      }
      
      const config = ELEMENTS[type];
      const container = document.getElementById("rotationContainer");
      if (!container) {
        console.error("Rotation container not found");
        return;
      }
      
      // Get animation positions
      const containerRect = container.getBoundingClientRect();
      const containerCenterX = containerRect.left + containerRect.width / 2;
      const containerCenterY = containerRect.top + containerRect.height / 2;
      const currentRotation = gsap.getProperty(container, "rotation") || 0;
      const absoluteAngle = randomElement.angle + currentRotation;
      const edgePos = getViewportEdgePosition(absoluteAngle);
      const offsetX = edgePos.x - containerCenterX;
      const offsetY = edgePos.y - containerCenterY;
      const localOffsetX = offsetX;
      const localOffsetY = offsetY + 210;
      
      // Animate from edge to planet
      gsap.set(randomElement.element, {
        x: localOffsetX,
        y: localOffsetY,
        opacity: 0,
        scale: 0.2
      });
      
      const tl = gsap.timeline();
      tl.to(randomElement.element, {
        opacity: 1,
        duration: 0.3
      }).to(randomElement.element, {
        x: 0,
        y: config.yPos,
        scale: 1,
        duration: 1.2,
        ease: "bounce.out"
      });
      
      randomElement.grown = true;
      gameState.counts[type]++;
      updateTimeEra();
    }
  
    // Unified function to shrink any element type
    function shrinkRandomElement(type) {
      const grownElements = gameState.elements[type].filter(item => item.grown);
      if (grownElements.length === 0) return;
      
      const randomElement = grownElements[Math.floor(Math.random() * grownElements.length)];
      const config = ELEMENTS[type];
      const container = document.getElementById("rotationContainer");
      
      // Get animation positions
      const containerRect = container.getBoundingClientRect();
      const containerCenterX = containerRect.left + containerRect.width / 2;
      const containerCenterY = containerRect.top + containerRect.height / 2;
      const currentRotation = gsap.getProperty(container, "rotation") || 0;
      const absoluteAngle = randomElement.angle + currentRotation;
      const edgePos = getViewportEdgePosition(absoluteAngle);
      const offsetX = edgePos.x - containerCenterX;
      const offsetY = edgePos.y - containerCenterY + 210;
      
      // Animate to edge
      gsap.to(randomElement.element, {
        x: offsetX,
        y: offsetY,
        opacity: 0,
        scale: 0.1,
        duration: 1.0,
        ease: "power2.in",
        onComplete: () => {
          gsap.set(randomElement.element, {
            x: 0,
            y: config.yPos,
            scale: 0
          });
        }
      });
      
      randomElement.grown = false;
      gameState.counts[type]--;
      updateTimeEra();
    }
  
    // Start world rotation
    function startRotation(speed = 60) {
      if (gameState.intervals.rotation) gameState.intervals.rotation.kill();
      
      if (speed < 0) {
        gameState.intervals.rotation = gsap.to("#rotationContainer", {
          rotation: "-=360",
          duration: Math.abs(speed),
          ease: "none",
          repeat: -1
        });
      } else {
        gameState.intervals.rotation = gsap.to("#rotationContainer", {
          rotation: "+=360", 
          duration: speed,
          ease: "none",
          repeat: -1
        });
      }
    }
  
    // Clear all containers and reset state
    function clearAll() {
      Object.keys(ELEMENTS).forEach(type => {
        gameState.containers[type].innerHTML = '';
        gameState.elements[type] = [];
        gameState.counts[type] = 0;
      });
    }
  
    // Initialize all element types
    function initializeAll() {
      Object.keys(ELEMENTS).forEach(type => {
        initializeElements(type);
      });
    }
  
    // Special functions for reinterpretation mode
    function removeIndustrialBuildings() {
      const industrialTypes = ['oilRigs', 'antennas', 'nuclear', 'smokestacks', 'spaceJunk'];
      const industrialElements = [];
      
      industrialTypes.forEach(type => {
        gameState.elements[type].filter(item => item.grown).forEach(item => {
          industrialElements.push({...item, type});
        });
      });
  
      industrialElements.forEach((item, index) => {
        setTimeout(() => {
          const container = document.getElementById("rotationContainer");
          const containerRect = container.getBoundingClientRect();
          const containerCenterX = containerRect.left + containerRect.width / 2;
          const containerCenterY = containerRect.top + containerRect.height / 2;
          const currentRotation = gsap.getProperty(container, "rotation") || 0;
          const absoluteAngle = item.angle + currentRotation;
          const edgePos = getViewportEdgePosition(absoluteAngle);
          const offsetX = edgePos.x - containerCenterX;
          const offsetY = edgePos.y - containerCenterY + 210;
  
          gsap.to(item.element, {
            x: offsetX,
            y: offsetY,
            opacity: 0,
            scale: 0.1,
            duration: 1.0,
            ease: "power2.in",
            onComplete: () => {
              if (item.element && item.element.parentNode) {
                item.element.parentNode.removeChild(item.element);
              }
              item.grown = false;
            }
          });
        }, index * 100);
      });
    }
  
    function animateAllElementsOffWorld() {
      const allElements = [];
      
      Object.keys(ELEMENTS).forEach(type => {
        gameState.elements[type].filter(item => item.grown).forEach(item => {
          allElements.push({...item, type});
        });
      });
  
      // Shuffle to avoid spiral effect
      const shuffledElements = allElements.sort(() => Math.random() - 0.5);
  
      shuffledElements.forEach((item, index) => {
        setTimeout(() => {
          const container = document.getElementById("rotationContainer");
          const containerRect = container.getBoundingClientRect();
          const containerCenterX = containerRect.left + containerRect.width / 2;
          const containerCenterY = containerRect.top + containerRect.height / 2;
          const currentRotation = gsap.getProperty(container, "rotation") || 0;
          const absoluteAngle = item.angle + currentRotation;
          const edgePos = getViewportEdgePosition(absoluteAngle);
          const offsetX = edgePos.x - containerCenterX;
          const offsetY = edgePos.y - containerCenterY + 210;
  
          gsap.to(item.element, {
            x: offsetX,
            y: offsetY,
            opacity: 0,
            scale: 0.1,
            duration: 1.0,
            ease: "power2.in",
            onComplete: () => {
              if (item.element && item.element.parentNode) {
                item.element.parentNode.removeChild(item.element);
              }
              item.grown = false;
            }
          });
        }, index * 80);
      });
    }
  
    // Mode switching functions
    function enterReinterpretationMode() {
      gameState.isReinterpretationMode = true;
      gameState.splashesDisabled = true;
      
      removeIndustrialBuildings();
      
      setTimeout(() => {
        clearAll();
        initializeElements('trees');
        initializeElements('cities');
        
        setTimeout(() => {
          // Start with more trees initially
          for (let i = 0; i < 12; i++) {
            setTimeout(() => growRandomElement('trees'), i * 200);
          }
          // Start with more cities initially (grow 8 out of 12 available)
          for (let i = 0; i < 8; i++) {
            setTimeout(() => growRandomElement('cities'), i * 300 + 1000);
          }
        }, 500);
      }, 1500);
    }
  
    function resetTo3050AD() {
      if (!gameState.isReinterpretationMode) return;
      
      animateAllElementsOffWorld();
      
      setTimeout(() => {
        gameState.isReinterpretationMode = false;
        clearAll();
        initializeAll();
        
        setTimeout(() => {
          const industrialTypes = ['oilRigs', 'antennas', 'cities', 'nuclear', 'smokestacks', 'spaceJunk'];
          industrialTypes.forEach((type, typeIndex) => {
            const total = ELEMENTS[type].total;
            for (let i = 0; i < total; i++) {
              setTimeout(() => growRandomElement(type), i * 100 + typeIndex * 50);
            }
          });
        }, 500);
      }, 1500);
    }
  
    // Time era calculation with automatic progression
    function updateTimeEra() {
      const treePercentage = gameState.counts.trees / ELEMENTS.trees.total;
      const industrialTypes = ['oilRigs', 'antennas', 'nuclear', 'smokestacks', 'spaceJunk'];
      const allIndustrialFull = industrialTypes.every(type => 
        gameState.counts[type] >= ELEMENTS[type].total
      );
      
      let era = "Beginning";
      let bgColor = "rgba(0, 0, 0, 0.7)";
      
      if (gameState.isReinterpretationMode) {
        era = "A Better Future";
        bgColor = "rgba(0, 150, 0, 0.8)";
      } else {
        // Era logic simplified
        if (treePercentage === 0 && allIndustrialFull) {
          era = "3050 AD";
          bgColor = "rgba(10, 220, 120, 0.7)";
        } else if (treePercentage >= 1.0 && allIndustrialFull) {
          era = "2250 AD";
          bgColor = "rgba(40, 160, 80, 0.7)";
        } else if (treePercentage >= 1.0) {
          era = "1750 AD";
          bgColor = "rgba(60, 120, 60, 0.7)";
        } else if (treePercentage > 0) {
          era = "1300 AD";
          bgColor = "rgba(90, 70, 50, 0.7)";
        } else {
          era = "1050 AD";
          bgColor = "rgba(100, 50, 50, 0.7)";
        }
      }
      
      const timeIndicator = document.getElementById('timeIndicator');
      if (timeIndicator) {
        timeIndicator.textContent = era;
        gsap.to(timeIndicator, { background: bgColor, duration: 0.5 });
      }
      
      // Show navigation at key points
      if (!gameState.splashesDisabled) {
        if (gameState.counts.trees === 30 && !gameState.navShown.nav2) {
          showNav('2');
          gameState.navShown.nav2 = true;
        }
        if (treePercentage >= 1.0 && allIndustrialFull && !gameState.navShown.nav3) {
          showNav('3');
          gameState.navShown.nav3 = true;
          
          // Start automatic tree removal after nav-3 is shown to ensure progression
          setTimeout(() => {
            const autoRemovalInterval = setInterval(() => {
              if (gameState.counts.trees > 0 && !gameState.navShown.nav4) {
                shrinkRandomElement('trees');
              } else {
                clearInterval(autoRemovalInterval);
              }
            }, 800);
          }, 3000); // Give user 3 seconds to see nav-3, then start auto-removal
        }
        if (treePercentage === 0 && allIndustrialFull && !gameState.navShown.nav4) {
          showNav('4');
          gameState.navShown.nav4 = true;
        }
      }
    }
  
    // Show navigation overlays
    function showNav(navName) {
      const nav = document.querySelector(`.nav-${navName}`);
      if (!nav) {
        console.error(`Navigation element .nav-${navName} not found`);
        return;
      }
      nav.style.display = "flex";
      gsap.set(nav, { y: window.innerHeight, opacity: 0 });
      gsap.to(nav, {
        y: 0,
        opacity: 1,
        duration: 1.2,
        ease: "power2.out",
        onComplete: () => resetCursorToCenter()
      });
    }
  
    // Mouse and touch movement handler
    function handleMovement(e) {
      // Support both mouse and touch events
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const windowWidth = window.innerWidth;
      const leftBoundary = windowWidth * 0.3;
      const rightBoundary = windowWidth * 0.7;
      
      // Clear existing intervals safely
      if (gameState.intervals.growth) clearInterval(gameState.intervals.growth);
      if (gameState.intervals.shrink) clearInterval(gameState.intervals.shrink);
      
      // Remove active classes safely
      ['leftZone', 'centerZone', 'rightZone'].forEach(id => {
        const element = document.getElementById(id);
        if (element) element.classList.remove('active');
      });
      
      if (clientX < leftBoundary) {
        const leftZone = document.getElementById('leftZone');
        if (leftZone) leftZone.classList.add('active');
        startRotation(-20);
        
        if (gameState.isReinterpretationMode) {
          resetTo3050AD();
          return;
        }
        
        // Shrink elements in reverse order
        gameState.intervals.shrink = setInterval(() => {
          const shrinkOrder = ['spaceJunk', 'smokestacks', 'nuclear', 'cities', 'antennas', 'oilRigs', 'trees'];
          for (const type of shrinkOrder) {
            if (gameState.counts[type] > 0) {
              shrinkRandomElement(type);
              break;
            }
          }
        }, 800);
        
      } else if (clientX > rightBoundary) {
        const rightZone = document.getElementById('rightZone');
        if (rightZone) rightZone.classList.add('active');
        startRotation(20);
        
        if (gameState.isReinterpretationMode) {
          gameState.intervals.growth = setInterval(() => {
            // In reinterpretation mode, allow growth up to the reinterpretation totals
            const maxTrees = 34;
            const maxCities = 12;
            
            if (gameState.counts.trees < maxTrees) {
              growRandomElement('trees');
            } else if (gameState.counts.cities < maxCities) {
              growRandomElement('cities');
            }
          }, 400);
        } else {
          // Normal growth logic
          gameState.intervals.growth = setInterval(() => {
            const treePercentage = gameState.counts.trees / ELEMENTS.trees.total;
            const industrialTypes = ['oilRigs', 'antennas', 'nuclear', 'smokestacks', 'spaceJunk'];
            const allIndustrialFull = industrialTypes.every(type => 
              gameState.counts[type] >= ELEMENTS[type].total
            );
            
            if (gameState.counts.trees < ELEMENTS.trees.total && !allIndustrialFull) {
              growRandomElement('trees');
            } else if (treePercentage >= 1.0 && !allIndustrialFull) {
              // Grow industrial elements
              const growOrder = ['oilRigs', 'antennas', 'cities', 'nuclear', 'smokestacks', 'spaceJunk'];
              for (const type of growOrder) {
                if (gameState.counts[type] < ELEMENTS[type].total) {
                  growRandomElement(type);
                  break;
                }
              }
            } else if (allIndustrialFull && gameState.counts.trees > 0) {
              // Aggressively remove trees once all industrial is built - higher probability
              if (Math.random() < 0.9) {
                shrinkRandomElement('trees');
              }
            }
          }, 400); // Faster interval for better progression
        }
        
      } else {
        const centerZone = document.getElementById('centerZone');
        if (centerZone) centerZone.classList.add('active');
        startRotation(60);
      }
    }
  
    // Main initialization
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOM loaded, initializing...");
      
      // Initialize containers with error checking
      let allContainersFound = true;
      Object.keys(ELEMENTS).forEach(type => {
        const container = document.getElementById(ELEMENTS[type].containerID);
        if (!container) {
          console.error(`Container not found: ${ELEMENTS[type].containerID}`);
          allContainersFound = false;
          return;
        }
        gameState.containers[type] = container;
        gameState.counts[type] = 0;
      });
      
      if (!allContainersFound) {
        console.error("Some containers missing - initialization aborted");
        return;
      }
      
      // Check for required elements
      const timeIndicator = document.getElementById('timeIndicator');
      if (!timeIndicator) {
        console.error("Time indicator not found");
        return;
      }
      
      console.log("All containers found, proceeding with initialization...");
      
      // Initialize elements and start
      initializeAll();
      startRotation();
      updateTimeEra();
      
      // Start with a few trees
      setTimeout(() => {
        for (let i = 0; i < 4; i++) {
          setTimeout(() => growRandomElement('trees'), i * 1200);
        }
      }, 2000);
      
      // Event listeners - support both mouse and touch
      document.addEventListener('mousemove', handleMovement);
      document.addEventListener('touchmove', handleMovement, { passive: false });
      window.addEventListener('enterReinterpretationMode', enterReinterpretationMode);
      
      // Setup other components
      setupTutorial();
      setupNavigationButtons();
      setupCursorHiding();
      setupTextAnimations();
      
      console.log("Initialization complete");
    });
  
    // Tutorial setup
    function setupTutorial() {
      const tutorialElements = {
        right: document.querySelector(".tutorial-right"),
        left: document.querySelector(".tutorial-left"), 
        center: document.querySelector(".tutorial-center")
      };
      
      const zones = {
        right: document.getElementById("rightZone"),
        left: document.getElementById("leftZone"),
        center: document.getElementById("centerZone")
      };
      
      let tutorialStep = 0;
      
      tutorialElements.right.style.display = "block";
      tutorialElements.left.style.display = "none";
      tutorialElements.center.style.display = "none";
      
      function fadeOut(element) {
        element.classList.add("fade-out");
        setTimeout(() => {
          element.style.display = "none";
          element.classList.remove("fade-out");
        }, 600);
      }
      
      zones.right.addEventListener("mouseenter", () => {
        if (tutorialStep === 0) {
          fadeOut(tutorialElements.right);
          tutorialElements.left.style.display = "block";
          tutorialStep = 1;
        }
      });
      
      zones.left.addEventListener("mouseenter", () => {
        if (tutorialStep === 1) {
          fadeOut(tutorialElements.left);
          tutorialElements.center.style.display = "block";
          tutorialStep = 2;
        }
      });
      
      zones.center.addEventListener("mouseenter", () => {
        if (tutorialStep === 2) {
          fadeOut(tutorialElements.center);
          tutorialStep = 3;
        }
      });
    }
  
    // Navigation buttons setup
    function setupNavigationButtons() {
      const navConfigs = [
        { button: ".nav-window .button", nav: ".nav-1" },
        { button: ".nav-window-2 .button", nav: ".nav-2" },
        { button: ".nav-window-3 .button", nav: ".nav-3" },
        { button: ".nav-window-4 .button", nav: ".nav-4", showNext: ".nav-5" },
        { button: ".nav-window-5 .button", nav: ".nav-5", triggerReinterpretation: true }
      ];
      
      navConfigs.forEach((config, index) => {
        const button = document.querySelector(config.button);
        const nav = document.querySelector(config.nav);
        
        if (!button) {
          console.error(`Button not found: ${config.button}`);
          return;
        }
        if (!nav) {
          console.error(`Nav not found: ${config.nav}`);
          return;
        }
        
        function handleButtonClick() {
          resetCursorToCenter();
          gsap.to(nav, {
            y: -window.innerHeight,
            opacity: 0,
            duration: 1.2,
            ease: "power2.inOut",
            onComplete: () => {
              nav.style.display = "none";
              
              if (config.showNext) {
                setTimeout(() => {
                  const nextNav = document.querySelector(config.showNext);
                  if (nextNav) {
                    nextNav.style.display = "flex";
                    gsap.set(nextNav, { y: window.innerHeight, opacity: 0 });
                    gsap.to(nextNav, {
                      y: 0, opacity: 1, duration: 1.2, ease: "power2.out",
                      onComplete: () => resetCursorToCenter()
                    });
                  }
                }, 100);
              }
              
              if (config.triggerReinterpretation) {
                setTimeout(() => {
                  window.dispatchEvent(new CustomEvent('enterReinterpretationMode'));
                }, 200);
              }
            }
          });
        }
        
        // Add both click and touch events for mobile compatibility
        button.addEventListener("click", handleButtonClick);
        button.addEventListener("touchend", (e) => {
          e.preventDefault(); // Prevent double-firing on mobile
          resetCursorToCenter();
          handleButtonClick();
        });
      });
    }
  
    // Cursor hiding setup
    function setupCursorHiding() {
      let cursorTimer;
      
      function resetCursorTimer() {
        document.body.style.cursor = "default";
        clearTimeout(cursorTimer);
        cursorTimer = setTimeout(() => {
          document.body.style.cursor = "none";
        }, 6000);
      }
      
      document.addEventListener("mousemove", resetCursorTimer);
      resetCursorTimer();
    }
  
    // Text animations setup
    function setupTextAnimations() {
      try {
        if (typeof gsap === 'undefined' || typeof SplitText === 'undefined') {
          console.error("GSAP or SplitText not loaded");
          return;
        }
        
        gsap.registerPlugin(SplitText, TextPlugin);
        
        [".text", ".text-2", ".text-3", ".text-4", ".text-5"].forEach(selector => {
          const element = document.querySelector(selector);
          if (!element) {
            console.warn(`Text element not found: ${selector}`);
            return;
          }
          
          try {
            const split = SplitText.create(selector, { type: "chars words lines" });
            gsap.from(split.chars, {
              y: 100,
              autoAlpha: 0,
              stagger: { amount: selector === ".text" ? 0.25 : 1, from: "left" }
            });
          } catch (error) {
            console.error(`Error setting up animation for ${selector}:`, error);
          }
        });
      } catch (error) {
        console.error("Error in setupTextAnimations:", error);
      }
    }
  
  })();
  </script>

</body>
</html>